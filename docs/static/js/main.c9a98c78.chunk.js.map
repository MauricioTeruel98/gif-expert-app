{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","components/GifExpertApp.js","index.js"],"names":["AddCategory","setCategorys","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","console","log","GifGridItem","className","src","alt","GifGrid","loading","state","setstate","useEffect","then","imgs","setTimeout","useFetchGifs","GifExpertApp","categories","setCategories","ReactDOM","render","document","getElementById"],"mappings":"2MAGaA,EAAc,SAAC,GAAyE,IAAxEC,EAAuE,EAAvEA,aAEzB,EAAoCC,mBAAS,IAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KAuBA,OACI,mCACE,sBAAMC,SAlBS,SAACC,GAElBA,EAAEC,iBAECJ,EAAWK,OAAOC,OAAS,IAE1BR,GAAc,SAAAS,GAAI,OAAMP,GAAN,mBAAqBO,OACvCN,EAAc,MAWhB,SAEA,uBACMO,KAAK,OACLC,MAAQT,EACRU,SA5Bc,SAACP,GAEvBF,EAAcE,EAAEQ,OAAOF,e,+BCPlBG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAGbC,EAHa,iDAGoCC,UAAWH,GAH/C,+DAIAI,MAAMF,GAJN,cAIbG,EAJa,gBAKEA,EAAKC,OALP,uBAKZC,EALY,EAKZA,KAEDC,EAAOD,EAAKE,KAAI,SAAAC,GAAQ,IAAD,EACzB,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAI1Ca,QAAQC,IAAIR,GAfO,kBAiBZA,GAjBY,4CAAH,sDCePS,EAAc,SAAC,GAAsB,IAApBN,EAAmB,EAAnBA,GAAGC,EAAgB,EAAhBA,MAAMV,EAAU,EAAVA,IAInC,OAFAa,QAAQC,IAAI,CAACL,KAAGC,QAAMV,QAGlB,sBAAKgB,UAAU,yCAAf,UACI,qBAAKC,IAAKjB,EAAKkB,IAAKR,IAChB,4BAAIA,QCnBPS,EAAU,SAAC,GAAgB,IAAfrB,EAAc,EAAdA,SAIrB,ECHwB,SAAEA,GAE1B,MAA0Bd,mBAAS,CAC/BqB,KAAK,GACLe,SAAS,IAFb,mBAAOC,EAAP,KAAcC,EAAd,KA8BA,OAzBAC,qBAAU,WAEN1B,EAASC,GACJ0B,MAAK,SAAAC,GAEFC,YAAW,WAEPJ,EAAS,CACLjB,KAAMoB,EACNL,SAAS,MAGf,UAIX,CAACtB,IASGuB,ED7B0BM,CAAc7B,GAAlCa,EAAb,EAAON,KAAce,EAArB,EAAqBA,QAkCrB,OACI,qCAEA,oBAAIJ,UAAU,sDAAd,SAAqElB,IAEnEsB,GAAW,mBAAGJ,UAAU,mCAAb,qBAEb,qBAAKA,UAAU,YAAf,SAGYL,EAAOJ,KAAK,SAAAC,GAAG,OACX,cAAC,EAAD,eAGSA,GAFAA,EAAIC,aElDxBmB,EAAe,WAIxB,MAAoC5C,mBAAS,CAAC,WAA9C,mBAAO6C,EAAP,KAAmBC,EAAnB,KAUA,OACI,qCACG,gDACA,cAAC,EAAD,CAAa/C,aAAiB+C,IAC9B,uBAEA,6CAEC,6BAEQD,EAAWtB,KAAK,SAAAT,GAAQ,OAIpB,aAHA,CAGC,EAAD,CAEIA,SAAWA,GADNA,YC7BjCiC,IAASC,OACP,cAAC,EAAD,IACAC,SAASC,eAAe,W","file":"static/js/main.c9a98c78.chunk.js","sourcesContent":["import React, {useState} from 'react'\r\nimport PropTypes from 'prop-types';\r\n\r\nexport const AddCategory = ({setCategorys}/*Destructuracion de los argumentos del componente*/ ) => {\r\n\r\n    const [inputValue, setInputValue] = useState(''); //useState() si lo dejamos asi el valor será undefined\r\n\r\n    const handleInputChange = (e)=>{\r\n        //console.log(e.target.value);\r\n        setInputValue(e.target.value);\r\n    }\r\n\r\n    const handleSubmit = (e) => {\r\n\r\n        e.preventDefault();\r\n\r\n        if(inputValue.trim().length > 2){\r\n\r\n            setCategorys( cats => [ inputValue, ...cats] );\r\n            setInputValue('');\r\n\r\n        }\r\n\r\n        //console.log('Submit hecho')\r\n        //setCategory\r\n\r\n    }\r\n\r\n    return (\r\n        <>\r\n          <form onSubmit={handleSubmit}>\r\n\r\n          <input \r\n                type=\"text\"\r\n                value={ inputValue }\r\n                onChange={ handleInputChange }\r\n            />\r\n\r\n            </form>  \r\n        </>\r\n    )\r\n}\r\n\r\nAddCategory.propTypes = {\r\n    setCategorys: PropTypes.func.isRequired\r\n}\r\n\r\nexport default AddCategory;\r\n","// Son funciones que hacen ciertos trabajos\r\n\r\nexport const getGifs = async( category ) => {\r\n\r\n    //encodeURI: Reemplaza espacios con signo de % o + para que no genere problemas en la url\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI (category)}&limit=15&api_key=Xv5lQW9BXlB7AF6D7PHbxUlHoG4fO6h7`;\r\n    const resp = await fetch(url);\r\n    const {data} = await resp.json();\r\n\r\n    const gifs = data.map(img => {\r\n        return {\r\n            id: img.id,\r\n            title: img.title,\r\n            url: img.images?.downsized_medium.url\r\n        }\r\n    })\r\n\r\n    console.log(gifs);\r\n    \r\n    return gifs;\r\n\r\n}","import React from 'react'\r\n\r\n// ()Con props\r\n\r\n// export const GifGridItem = ( props ) => {\r\n\r\n//     console.log(props);\r\n\r\n//     return (\r\n//         <div>\r\n//             {/* {img.title} */}\r\n//         </div>\r\n//     )\r\n// }\r\n\r\n// ()Con destructuracion\r\n\r\nexport const GifGridItem = ( {id,title,url} ) => {\r\n\r\n    console.log({id,title,url});\r\n\r\n    return (\r\n        <div className='card animate__animated animate__bounce'>\r\n            <img src={url} alt={title}/>\r\n                <p>{title}</p>\r\n        </div>\r\n    )\r\n}","import React from 'react'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\n//import { getGifs } from '../helpers/getGifs';\r\nimport { GifGridItem } from './GifGridItem';\r\n\r\nexport const GifGrid = ({category}) => {  //en este GifGrid necesitamos recibir la categoria y realizar una peticion http\r\n\r\n    // const [images, setImages] = useState([]);\r\n\r\n    const {data: images, loading} =  useFetchGifs( category );\r\n    //data : images - renombra data por images\r\n\r\n    // useEffect( ()=> {\r\n    //    getGifs( category )\r\n    //         .then(imgs => setImages( imgs )); //(setImages)\r\n    // },[category]); \r\n    //Array o lista de dependencias\r\n\r\n    /*\r\n    //Todo esto lo pasamos hacia la carpeta helpers/getGifs\r\n    const getGifs = async() => {\r\n\r\n        //encodeURI: Reemplaza espacios con signo de % o + para que no genere problemas en la url\r\n        const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI (category)}&limit=15&api_key=Xv5lQW9BXlB7AF6D7PHbxUlHoG4fO6h7`;\r\n        const resp = await fetch(url);\r\n        const {data} = await resp.json();\r\n\r\n        const gifs = data.map(img => {\r\n            return {\r\n                id: img.id,\r\n                title: img.title,\r\n                url: img.images?.downsized_medium.url\r\n            }\r\n        })\r\n\r\n        console.log(gifs);\r\n        setImages(gifs);\r\n\r\n    }\r\n    */\r\n\r\n    //getGifs(); //Llamando de esta forma a la funcion se creará un ciclo infinito en donde siempre hará la peticion http cuando solamente es necesario hacerla una vez, para que solo lo realice una vez usamos el useEffect, como se lo muestra arriba\r\n\r\n    return (\r\n        <>\r\n\r\n        <h3 className='animate__animated animate__bounce animate__delay-4s'>{category}</h3>\r\n\r\n        { loading && <p className='animate__animated animate__flash'>Loading</p> }\r\n\r\n        <div className='card-grid'>\r\n            \r\n                {\r\n                    images.map( img => (\r\n                        <GifGridItem \r\n                            key={img.id}\r\n                            // img={img}\r\n                            { ...img }\r\n                        />\r\n                    ))\r\n                }\r\n                \r\n                {/*\r\n                    //(img) => (key={img.id} {img.title})\r\n                    images.map( ({id, title}) => ( \r\n                    <li key={id}>{title}</li>\r\n                    ))*/\r\n                }\r\n\r\n        </div>\r\n\r\n        </>\r\n    )\r\n}\r\n","// Custom hooks, todos los hooks comienzan con use\r\n// Los hooks no son mas que funciones\r\n\r\nimport { useEffect, useState } from \"react\"\r\nimport { getGifs } from \"../helpers/getGifs\";\r\n\r\nexport const useFetchGifs = ( category ) => {\r\n    \r\n    const [state, setstate] = useState({\r\n        data:[],\r\n        loading: true\r\n    });\r\n\r\n    useEffect(()=>{\r\n\r\n        getGifs( category )\r\n            .then(imgs =>{\r\n                \r\n                setTimeout(() => {\r\n                    \r\n                    setstate({\r\n                        data: imgs,\r\n                        loading: false\r\n                    })\r\n\r\n                },3000);\r\n\r\n            });\r\n\r\n    }, [category]);\r\n\r\n    // setTimeout(() => {\r\n    //     setstate({\r\n    //         data:[1,2,3,4,5,6,7,8,9],\r\n    //         loading: false\r\n    //     })\r\n    // }, 3000);\r\n\r\n    return state; //{data: [], loading: true};\r\n    \r\n}\r\n","//snipped: rafc\r\nimport React, {useState} from 'react'\r\nimport { AddCategory } from './AddCategory';\r\nimport { GifGrid } from './GifGrid';\r\n\r\nexport const GifExpertApp = () => {\r\n\r\n    //const categories = ['One Punch', 'Marvel', 'Dragon-Ball'];\r\n    //sipped: useState\r\n    const [categories, setCategories] = useState(['Marvel']);\r\n\r\n    // const handleAdd = () =>{\r\n    //     setCategories( /* estado anterior*/ cats => [...cats, 'HunterX'] ); //Sobreescribe el estado anterior, que en este caso es el array\r\n    //     console.log(categories)\r\n    // }\r\n\r\n    //Forma de comunicar componentes: Le pasamos la referencia de setCategories al componente de <AddCategory/> de esta manera:\r\n    // <AddCategory setCategory = { setCategories }/>  -  Aqui le estamos pasando propiedades a AddCategories\r\n\r\n    return (\r\n        <>\r\n           <h2>Gif Expert App</h2>\r\n           <AddCategory setCategorys = { setCategories }/>\r\n           <hr/>\r\n\r\n           <button>Agregar</button>\r\n\r\n            <ol>\r\n                {\r\n                    categories.map( category => \r\n                        //return <li key = { category }>{ category }</li>\r\n                        //El key siempre tiene que ser unico\r\n                        \r\n                        <GifGrid \r\n                            key={category}\r\n                            category={ category }\r\n                        />\r\n\r\n                    )\r\n                }\r\n            </ol>\r\n\r\n        </>\r\n    )\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport {GifExpertApp} from './components/GifExpertApp'\n\nReactDOM.render(\n  <GifExpertApp/>,\n  document.getElementById('root')\n);\n\n\n//GifExpertApp"],"sourceRoot":""}